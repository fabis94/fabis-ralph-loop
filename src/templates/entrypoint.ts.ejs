<%= generatedHeader %>
import { execSync, execFileSync } from 'node:child_process'
import { existsSync, writeFileSync } from 'node:fs'
import { createHash } from 'node:crypto'
import { join } from 'node:path'

function run(command: string, args: string[]): void {
  execFileSync(command, args, { stdio: 'inherit' })
}

function runShell(command: string): string {
  return execSync(command, { encoding: 'utf-8', stdio: ['pipe', 'pipe', 'pipe'] }).trim()
}

// === Git safety ===
run('git', ['config', '--global', '--add', 'safe.directory', '/workspace'])
run('git', ['config', '--global', 'url.blocked://push-disabled/.pushInsteadOf', 'https://'])
run('git', ['config', '--global', 'url.blocked://push-disabled/.pushInsteadOf', 'git@'])
run('git', ['config', '--global', 'url.blocked://push-disabled/.pushInsteadOf', 'ssh://'])

// === Validate agent CLI ===
const agent = '<%= agent %>'
try {
  const version = runShell(`${agent} --version`)
  console.log(`${agent} ${version} ready`)
} catch {
  console.error(`ERROR: ${agent} CLI is not working.`)
  process.exit(1)
}

// === Validate auth token ===
if (!process.env.CLAUDE_CODE_OAUTH_TOKEN) {
  console.error('ERROR: CLAUDE_CODE_OAUTH_TOKEN is not set.')
  console.error('  export CLAUDE_CODE_OAUTH_TOKEN=$(claude auth token)')
  process.exit(1)
}
console.log('Auth token present.')

// === Chown shadow volumes ===
const shadowVolumes: string[] = <%- JSON.stringify(shadowVolumes) %>

for (const sv of shadowVolumes) {
  try {
    execSync(`sudo mkdir -p ${sv}`, { stdio: 'pipe' })
    execSync(`sudo chown -R <%= user %>:<%= user %> ${sv}`, { stdio: 'pipe' })
  } catch (error) {
    console.warn(`Warning: Could not chown ${sv}:`, error)
  }
}

// === Direnv auto-allow ===
if (existsSync('/workspace/.envrc')) {
  try {
    const envrcContent = execSync('cat /workspace/.envrc', { encoding: 'utf-8' })
    const hash = createHash('sha256').update(envrcContent).digest('hex')
    const allowDir = join(process.env.HOME || '<%= homeDir %>', '.local/share/direnv/allow')
    execSync(`mkdir -p ${allowDir}`, { stdio: 'pipe' })
    writeFileSync(join(allowDir, hash), '/workspace/.envrc\n')
    console.log('direnv: auto-allowed /workspace/.envrc')

    try {
      const envExport = runShell('cd /workspace && direnv export bash 2>/dev/null || true')
      if (envExport) {
        for (const match of envExport.matchAll(/export ([^=]+)='([^']*)'/g)) {
          const key = match[1]
          if (key) process.env[key] = match[2]
        }
      }
    } catch {
      // direnv export may fail if .envrc has errors
    }
  } catch (error) {
    console.warn('Warning: Could not auto-allow direnv:', error)
  }
} else {
  console.log('Note: No .envrc found in /workspace, skipping direnv')
}
<% if (entrypointSetup.length > 0) { %>
// === Entrypoint setup commands ===
const entrypointSetupCommands: string[] = <%- JSON.stringify(entrypointSetup) %>

for (const cmd of entrypointSetupCommands) {
  console.log(`Running entrypoint setup: ${cmd}`)
  try {
    execSync(cmd, { stdio: 'inherit', cwd: '/workspace' })
  } catch (error: unknown) {
    const exitCode = (error as { status?: number }).status ?? 1
    console.error(`ERROR: Entrypoint setup command failed (exit ${exitCode}): ${cmd}`)
    process.exit(exitCode)
  }
}
<% } -%>

// === Signal ready ===
writeFileSync('/tmp/entrypoint-ready', '')
console.log('Entrypoint ready.')

// === Exec command ===
const args = process.argv.slice(2)
const cmd = args[0]
if (cmd) {
  try {
    execFileSync(cmd, args.slice(1), { stdio: 'inherit' })
  } catch (error: unknown) {
    const exitCode = (error as { status?: number }).status ?? 1
    process.exit(exitCode)
  }
}
